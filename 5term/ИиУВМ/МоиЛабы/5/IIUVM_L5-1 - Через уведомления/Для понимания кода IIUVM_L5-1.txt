Конечно, я подробно расскажу об алгоритме программы, как если бы это была защита лабораторной работы. Давайте пройдемся по коду и рассмотрим каждую функцию в порядке их выполнения.

1. Начало программы:
   - Программа начинается с подключения необходимых заголовочных файлов для работы с Windows API, USB-устройствами и стандартными библиотеками C++.

2. Глобальные переменные и структуры:
   - Объявляется глобальная переменная `lastSafelyRemovedDeviceId` для хранения идентификатора последнего безопасно извлеченного устройства.
   - Определяется структура `Device`, которая содержит информацию об USB-устройстве:
     - `name`: имя устройства
     - `hardwareId`: аппаратный идентификатор
     - `ejectable`: флаг, указывающий, можно ли извлечь устройство
     - `devInst`: дескриптор устройства
   - Структура `Device` также содержит методы:
     - `print()`: для вывода информации об устройстве
     - `eject()`: для безопасного извлечения устройства
   - Объявляется глобальный вектор `devices` для хранения списка обнаруженных устройств.

3. Функция `updateDeviceList()`:
   - Эта функция обновляет список USB-устройств.
   - Сначала очищается текущий список устройств.
   - Затем используется `SetupDiGetClassDevsW` для получения информации о классе USB-устройств.
   - В цикле перебираются все найденные устройства:
     - Для каждого устройства получается имя, аппаратный идентификатор и свойства.
     - Создается объект `Device` и добавляется в вектор `devices`.
   - После обработки всех устройств освобождаются ресурсы.

4. Функция `printDevices()`:
   - Очищает консоль и выводит список USB-устройств.
   - Для каждого устройства выводится его номер, аппаратный ID и имя.
   - В конце выводится инструкция для пользователя.

5. Функция `WndProc()`:
   - Это оконная процедура для обработки сообщений Windows.
   - Обрабатывает сообщения о подключении и отключении устройств:
     - При подключении или отключении устройства обновляет список и выводит его.
     - Выводит сообщения о попытках безопасного извлечения.

6. Функция `checkForUnsafeRemoval()`:
   - Проверяет, не было ли устройство извлечено небезопасно.
   - Сравнивает текущий список устройств с предыдущим.
   - Если устройство исчезло из списка и не было безопасно извлечено, выводит предупреждение.
   - Обновляет список предыдущих устройств и очищает список сообщенных устройств.

7. Функция `main()`:
   - Устанавливает локаль для корректного отображения русских символов.
   - Регистрирует класс окна и создает скрытое окно для обработки сообщений.
   - Регистрирует уведомления об изменениях USB-устройств.
   - Запускает основной цикл программы:
     - Обрабатывает сообщения Windows.
     - Проверяет ввод пользователя:
       - 'q' или 'Q' для выхода.
       - Цифры от 1 до 9 для попытки извлечения соответствующего устройства.
     - Периодически вызывает `checkForUnsafeRemoval()` для проверки небезопасного извлечения.
   - После завершения цикла отменяет регистрацию уведомлений и завершает программу.

Этот алгоритм позволяет программе отслеживать подключение и отключение USB-устройств, предоставлять пользователю возможность безопасно извлекать устройства и предупреждать о небезопасном извлечении.





1. `SetupDiGetClassDevsW(&GUID_DEVINTERFACE_USB_DEVICE, nullptr, nullptr, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE)`

   - `&GUID_DEVINTERFACE_USB_DEVICE`: Указатель на GUID (Globally Unique Identifier) для интерфейса USB-устройств. Это позволяет функции фокусироваться только на USB-устройствах.
   - `nullptr, nullptr`: Первый - для имени перечислителя (не используется), второй - для родительского окна (не требуется).
   - `DIGCF_PRESENT | DIGCF_DEVICEINTERFACE`: Флаги, указывающие, что нужно возвращать только присутствующие устройства (DIGCF_PRESENT) и устройства, поддерживающие интерфейсы устройств (DIGCF_DEVICEINTERFACE).

2. `SetupDiEnumDeviceInfo(deviceInfo, i, &devInfoData)`

   - `deviceInfo`: Handle набора устройств, полученный от SetupDiGetClassDevsW.
   - `i`: Индекс устройства в наборе. Функция вызывается в цикле для перебора всех устройств.
   - `&devInfoData`: Указатель на структуру SP_DEVINFO_DATA, которая будет заполнена информацией об устройстве.

3. `SetupDiGetDeviceRegistryPropertyW(deviceInfo, &devInfoData, SPDRP_DEVICEDESC, nullptr, reinterpret_cast<PBYTE>(buffer), sizeof(buffer), nullptr)`

   - `deviceInfo` и `&devInfoData`: Те же, что и в предыдущей функции.
   - `SPDRP_DEVICEDESC`: Флаг, указывающий, что нужно получить описание устройства.
   - `nullptr`: Тип данных (не используется, определяется автоматически).
   - `reinterpret_cast<PBYTE>(buffer)`: Буфер для хранения полученных данных, приведенный к типу PBYTE.
   - `sizeof(buffer)`: Размер буфера.
   - `nullptr`: Указатель для получения требуемого размера буфера (не используется).

4. `CM_Request_Device_EjectW(devInst, nullptr, nullptr, 0, 0)`

   - `devInst`: Дескриптор экземпляра устройства для извлечения.
   - `nullptr, nullptr`: Указатели на функции обратного вызова (не используются).
   - `0, 0`: Флаги и зарезервированный параметр (не используются в данном случае).

5. `RegisterDeviceNotificationW(hWnd, &notificationFilter, DEVICE_NOTIFY_WINDOW_HANDLE)`

   - `hWnd`: Handle окна, которое будет получать уведомления.
   - `&notificationFilter`: Указатель на структуру DEV_BROADCAST_DEVICEINTERFACE, описывающую тип уведомлений.
   - `DEVICE_NOTIFY_WINDOW_HANDLE`: Флаг, указывающий, что hWnd - это handle окна.

Эти функции являются частью Windows API и используются для взаимодействия с системой управления устройствами Windows. Они позволяют получать информацию об устройствах, управлять ими и получать уведомления об изменениях в состоянии устройств.

CM_ префикс:
CM_ означает "Configuration Manager" (Менеджер конфигурации). Это часть Windows Device Installation framework. Функции с префиксом CM_ используются для управления устройствами и их конфигурацией в системе Windows.






