#include "stdafx.h"
#include "hexioctrl.h"
#include "(PCI_DEVS)pci_codes.h"
#include <stdio.h>
#include <conio.h>
#include <iostream>
#include <iomanip>
#include <string.h>

// Определение массива для хранения данных устройства
unsigned short driveData[256]; 

// Прототипы функций
void WaitWhileBusy(int channel); // Ожидание сброса бита BSY
bool RetrieveDriveInfo(int device, int channel); // Получение информации об устройстве
void DisplayDriveDetails(); // Отображение деталей устройства
bool WaitUntilReady(int channel); // Проверка готовности устройства к записи команды

int main()
{
    ALLOW_IO_OPERATIONS; // Разрешение операций ввода-вывода (для работы с портами ввода-вывода)
    setlocale(LC_ALL, "Russian"); // Установка локали для поддержки русского языка в выводе

    // Цикл по каждому каналу (0 - первичный, 1 - вторичный)
    for (int channel = 0; channel < 2; channel++) 
    {
        // Цикл по каждому устройству (0 - master, 1 - slave)
        for (int device = 0; device < 2; device++) 
        {
            // Если устройство отвечает, вывести информацию о нем
            if (RetrieveDriveInfo(device, channel))
            {
                printf("\n Канал %d | Устройство %d\n", channel, device);
                printf("======================================\n");
                DisplayDriveDetails();
            }
        }
    }

    system("pause"); // Ожидание перед закрытием программы
    return 0;
}

// Проверка готовности устройства к приему команды
bool WaitUntilReady(int channel)
{
    // Определение порта для чтения статуса в зависимости от канала
    unsigned short statusPort = (channel == 0) ? 0x3F6 : 0x376; // 0x3F6 - порт статуса для первичного канала, 0x376 - для вторичного

    for (int i = 0; i < 1000; i++) // Цикл ожидания готовности
    {
        unsigned char status = _inp(statusPort); // Чтение регистра статуса
        if (status & (1 << 6)) return true; // Проверка, установлен ли бит RDY (готовность)
    }
    return false; // Тайм-аут, устройство не готово
}

// Ожидание сброса бита BSY (занятости)
void WaitWhileBusy(int channel)
{
    // Определение порта для чтения статуса
    unsigned short statusPort = (channel == 0) ? 0x3F6 : 0x376; 

    unsigned char status;
    do
    {
        status = _inp(statusPort); // Чтение регистра статуса
    } while (status & (1 << 7)); // Проверка, установлен ли бит BSY (занятость)
}

// Получение информации об устройстве
bool RetrieveDriveInfo(int device, int channel)
{
    // Адрес регистра Device/Head для выбора устройства
    unsigned short deviceHeadPort = (channel == 0) ? 0x1F6 : 0x176; // 0x1F6 - первичный канал, 0x176 - вторичный

    // Адрес команды для выполнения (выбор команды Identify)
    unsigned short commandPort = (channel == 0) ? 0x1F7 : 0x177; // 0x1F7 - первичный канал, 0x177 - вторичный

    for (int attempt = 0; attempt < 2; attempt++) // Две попытки выполнения команды
    {
        WaitWhileBusy(channel); // Ожидание готовности устройства

        unsigned char devHead = (device << 4) + (7 << 5); // Формирование значения Device/Head
        _outp(deviceHeadPort, devHead); // Отправка значения в порт Device/Head

        if (!WaitUntilReady(channel)) return false; // Проверка готовности

        // Отправка команды Identify (0xA1 для ATAPI, 0xEC для ATA)
        _outp(commandPort, (attempt == 0) ? 0xA1 : 0xEC);
        WaitWhileBusy(channel); // Ожидание завершения

        unsigned char status = _inp(commandPort); // Чтение статуса
        if (!(status & (1 << 3))) // Проверка бита DRQ (данные готовы)
        {
            if (attempt == 1) return false; // Если после второй попытки данных нет, выйти
            continue;
        }
        else break; // Если данные готовы, выйти из цикла
    }

    // Считывание данных устройства
    unsigned short dataPort = (channel == 0) ? 0x1F0 : 0x170; // Порт данных
    for (int i = 0; i < 256; i++)
    {
        driveData[i] = _inpw(dataPort); // Считывание 256 слов данных
    }

    return true;
}

// Отображение данных об устройстве
void DisplayDriveDetails()
{
    printf("   Модель устройства: ");
    for (int i = 27; i <= 46; i++) // Слова 27-46: модель устройства
        printf("%c%c", driveData[i] >> 8, driveData[i] & 0xFF);

    printf("\n   Серийный номер: ");
    for (int i = 10; i <= 19; i++) // Слова 10-19: серийный номер
        printf("%c%c", driveData[i] >> 8, driveData[i] & 0xFF);

    printf("\n   Версия прошивки: ");
    for (int i = 23; i <= 26; i++) // Слова 23-26: версия прошивки
        printf("%c%c", driveData[i] >> 8, driveData[i] & 0xFF);

    printf("\n   Тип интерфейса: ");
    if (driveData[0] & (1 << 15)) // Проверка бита 15: ATAPI или ATA
        printf("ATAPI\n");
    else
        printf("ATA\n");

    if (!(driveData[0] & (1 << 15)))
    {
        // Расчет объема (записан в словах 60-61)
        printf("   Объем: %.2lf ГБ\n", (long double)(((unsigned long *)driveData)[30]) * 512 / (1024 * 1024 * 1024));
    }

    // Поддерживаемые режимы передачи
    printf("\n   Поддерживаемые режимы:\n");
    printf("   PIO: ");
    if (driveData[64] & 1) printf("PIO 3, ");
    if (driveData[64] & 2) printf("PIO 4\n");

    printf("   Multiword DMA: ");
    if (driveData[63] & 1) printf("MWDMA 0, ");
    if (driveData[63] & 2) printf("MWDMA 1, ");
    if (driveData[63] & 4) printf("MWDMA 2\n");

    printf("   Ultra DMA: ");
    if (driveData[88] & 1) printf("UDMA 0, ");
    if (driveData[88] & (1 << 1)) printf("UDMA 1, ");
    if (driveData[88] & (1 << 2)) printf("UDMA 2, ");
    if (driveData[88] & (1 << 3)) printf("UDMA 3, ");
    if (driveData[88] & (1 << 4)) printf("UDMA 4, ");
    if (driveData[88] & (1 << 5)) printf("UDMA 5\n");

    // Версии ATA
    printf("   Версии ATA:" );
    if(driveData[80] & (1 << 1)) printf(" ATA 1," );
    if(driveData[80] & (1 << 2)) printf(" ATA 2," );
    if(driveData[80] & (1 << 3)) printf(" ATA 3," );
    if(driveData[80] & (1 << 4)) printf(" ATA 4," );
    if(driveData[80] & (1 << 5)) printf(" ATA 5," );
    if(driveData[80] & (1 << 6)) printf(" ATA 6," );
    if(driveData[80] & (1 << 7)) printf(" ATA 7\n" );

    printf("\n-----------------------------------------------------------------\n");
}
