INITIAL_VALUE = 0x00
POLYNOM = 0xA9
0хA9
169
10101001
P(x)=x^7+x^5+x^3+1

def create_frame(self, data):
        flag = b'@u'  # '@' и 'u' (ASCII 117, что равно 'a' + 21 - 1)
        destination_address = b'\x00'
        source_address = bytes([int(self.ser_out.port[3:])])

        if len(data) < 21:
            # Если данные короче 21 байта, добавляем терминатор и заполняем нулями
            padded_data = data + TERMINATOR + b'0' * (20 - len(data))
        else:
            # Если данные ровно 21 байт, оставляем как есть
            padded_data = data

        # Вычисляем CRC8 для padded_data
        crc = self.compute_crc8(padded_data)

        # Объединяем все части кадра, кроме флага
        frame_without_flag = destination_address + source_address + padded_data + bytes([crc])

        return flag, frame_without_flag

    def introduce_error(self, data, probability=0.4):
        if random.random() <= probability:  # С вероятностью, заданной probability, вносим ошибку в данные
            byte_array = bytearray(data)  # Преобразуем данные в массив байтов
            byte_index = random.randint(0, len(byte_array) - 1)  # Выбираем случайный индекс байта в массиве
            bit_index = random.randint(0, 7)  # Выбираем случайный бит в выбранном байте
            byte_array[byte_index] ^= (1 << bit_index)  # Инвертируем выбранный бит, единичку сдвигаем влево на индекс
            data = bytes(byte_array)  # Преобразуем обратно в байты и возвращаем измененные данные
        return data  # Возвращаем (возможно, измененные) данные

    def compute_crc8(self, data: bytes) -> int:
        remainder = INITIAL_VALUE  # Инициализация остатка CRC с начальным значением
        for byte in data:  # Проходим по каждому байту данных
            remainder ^= byte  # Применяем XOR остатка с текущим байтом || промежуточный, первый остаточек, под чертой
            for _ in range(8):  # Выполняем обработку каждого бита байта
                remainder <<= 1  # Сдвигаем остаток влево на 1 бит // снос следующего бита сверху
                if (remainder & 0x80) != 0:  # Проверяем, если старший бит равен 1, то применяем полином XOR
                    remainder ^= (POLYNOM | 0x80)
        return remainder

       # 010110100


    def cyclic_shift_correction(self, message: bytes, crc: int) -> bytes:
        weight = bin(crc).count('1')  # Определяем количество единичных битов в CRC \ bin - binary
        shift_message = bytearray(message)  # Преобразуем сообщение в массив байтов для изменения
        if weight <= 1:  # Если вес CRC меньше или равен 1, XOR последнего байта с CRC
            shift_message[-1] ^= crc  # XOR последнего байта с CRC
            return bytes(shift_message)  # Возвращаем измененное сообщение

        count_shifts = 0  # Инициализируем счетчик количества сдвигов
        size_bits = len(shift_message) * 8  # Определяем размер сообщения в битах

        for _ in range(size_bits):  # Пробуем циклически сдвигать сообщение, пока не найдем подходящий CRC
            count_shifts += 1  # Увеличиваем счетчик сдвигов
            shift_message = self.left_cycle_shift(shift_message)  # Выполняем циклический сдвиг влево
            crc = self.compute_crc8(shift_message)  # Пересчитываем CRC для сдвинутого сообщения
            if bin(crc).count('1') <= 1:  # Если количество единичных битов в CRC <= 1
                shift_message[-1] ^= crc  # XOR с CRC
                for _ in range(count_shifts):  # Возвращаем сдвинутые байты в исходное положение
                    shift_message = self.right_cycle_shift(shift_message)  # Выполняем циклический сдвиг вправо
                return bytes(shift_message)  # Возвращаем скорректированное сообщение
        return message  # Если не удалось найти корректировку, возвращаем исходное сообщение

       # 001011010 011011010 101011010
    def right_cycle_shift(self, byte_message: bytearray) -> bytearray:
        shift_byte_message = bytearray(len(byte_message))  # Создаем новый массив байтов для хранения результата сдвига
        lowest_bit_of_last_byte = byte_message[-1] & 1  # Получаем наименьший бит последнего байта
        for i in range(len(byte_message)):  # Проходим по всем байтам
            shift_byte_message[i] = (byte_message[i] & 0xFF) >> 1  # Сдвигаем текущий байт на 1 бит вправо
            if i > 0:  # Если это не первый байт, добавляем последний бит предыдущего байта
                shift_byte_message[i] |= (byte_message[i - 1] & 1) << 7
        shift_byte_message[0] |= lowest_bit_of_last_byte << 7  # На первый байт добавляем наименьший бит последнего байта
        return shift_byte_message  # Возвращаем результат сдвига вправо

    def left_cycle_shift(self, byte_message: bytearray) -> bytearray:
        shift_byte_message = bytearray(len(byte_message))  # Создаем новый массив байтов для хранения результата сдвига
        highest_bit_of_first_byte = (byte_message[0] & 0x80) >> 7  # Получаем старший бит первого байта
        for i in range(len(byte_message)):  # Проходим по всем байтам
            shift_byte_message[i] = ((byte_message[i] & 0xFF) << 1) & 0xFF  # Сдвигаем текущий байт на 1 бит влево
            if i < len(byte_message) - 1:  # Если это не последний байт, добавляем старший бит следующего байта
                shift_byte_message[i] |= (byte_message[i + 1] & 0x80) >> 7
        shift_byte_message[-1] |= highest_bit_of_first_byte  # На последний байт добавляем старший бит первого байта
        return shift_byte_message  # Возвращаем результат сдвига влево
        
    def receive_data(self):
       buffer = b''
       expected_frame_length = 26  # 2 (flag) + 1 (dest) + 1 (source) + 21 (data) + 1 (CRC)
       while not self.stop_receive_thread:
           if self.ser_in and self.ser_in.is_open:
               try:
                   if self.ser_in.in_waiting >= expected_frame_length:
                       buffer = self.ser_in.read(self.ser_in.in_waiting)
                       if buffer.startswith(b'@u'):
                            flag = buffer[0:2]
                            frame_without_flag = buffer[2:]  # Исключаем флаг из кадра

                            # Анстаффинг без флага
                            unstuffed_frame = self.unstuffing(frame_without_flag)

                            destination_address = unstuffed_frame[0]
                            source_address = unstuffed_frame[1]
                            data = unstuffed_frame[2:23]  # 21 байт данных
                            received_crc = unstuffed_frame[23]  # Последний байт - CRC

                            # Вносим ошибку с вероятностью 40%
                            # data_with_error = self.introduce_error(data)

                            # Проверяем CRC
                            # calculated_crc = self.compute_crc8(data)
                            # if calculated_crc == received_crc:
                                # pass  CRC совпадает, ошибок нет - Продолжаем обработку данных
                            # else: CRC не совпадает, ошибка обнаружена
                                # corrected_data = self.cyclic_shift_correction(data, received_crc) # Попытка исправления ошибки циклическим сдвигом

                            # Ищем терминатор и обрезаем данные, если он найден
                            if TERMINATOR in data:
                                actual_data = data.split(TERMINATOR)[0]
                            else:
                                actual_data = data

                            self.update_output_text(actual_data.decode(errors='ignore'))

               except serial.SerialException as e:
                   self.log_status(f"Ошибка при чтении данных: {str(e)}")
                   break
                   
                   
у меня 8 контрольных битов значит берем полином 7 степени

проверка на возникновение ошибки происходит на стороне приемника

сколько  контрольных разрядов K = Rlog2((m+1) + Rlog2(m+1))
где m=21*8=168
K = Rlog2(169 + 8)
K = 8

Сдвигаем биты внутри байтов.

bytes([crc]) — преобразует CRC в байт.

shift_message — временный массив для сдвига данных.

[-1] и [0] — работа с последним и первым элементами массива для циклического сдвига.

информационный полином сколько?
порождающий сколько ?

как учли разрядность информационного полинома, чтобы лишнего не передавалось ?
