// операции с бинарным деревом
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <dos.h>
#include <locale.h>
#define N 20          // размерность информационного поля

struct tree
{
	char *inf;         // информационное поле
	int n;             // число встреч инф. поля в бинарном дереве
	tree *L, *R;       // указатель на левое и правое поддерево
};

void show_1(tree *);
void show_2(tree *);
void print(tree *, int = 0);
tree *creat1(tree *, char *);
tree *creat2(tree *, char *);
tree *erase(tree *);

int main()
{
	tree *dr = nullptr;        // адрес корня бинарного дерева
	char * st;
	setlocale(LC_ALL, "Russian");
	while (1)
	{
		puts("\nвид операции: 1-создать дерево не рекурсивно");
		puts("              2-создать дерево рекурсивно");
		puts("              3-рекурсивный вывод содержимого дерева");
		puts("              4-нерукурсивный вывод содержимого дерева");
		puts("              5-псевдографический вывод содержимого дерева");
		puts("              6-удаление любого элемента из дерева");
		puts("              7-выход");
		fflush(stdin);
		switch (getch())
		{
		case '1':
			puts("Введите информацию о узле дерева и <Enter>");
			puts("по окончании ввода просто нажмите еще раз <Enter> без ввода информации");
			st = (char *)malloc(N);
			while (1)
			{
				gets(st);
				if(*st) dr = creat1(dr, st);
				else break;
			}
			free(st);
			break;
		case '2':
			puts("Введите информацию о узле дерева и <Enter>");
			puts("по окончании ввода просто нажмите еще раз <Enter> без ввода информации");
			st = (char*)malloc(N);
			while (1)
			{
				gets(st);
				if(*st) dr = creat2(dr, st);
				else break;
			}
			free(st);
			break;
		case '3': show_1(dr); getch(); break;
		case '4': show_2(dr); getch(); break;
		case '5': print(dr); getch(); break;
		case '6': erase(dr); break;
		case '7': return 0;
		default: puts("ошибка в выборе варианта");
		}
	}
	puts("\n");
	return 0;
}

// нерекурсивное создание бинарного дерева
// новый элемент (узел, лист) добавляется в конец ветви дерева 
tree* creat1(tree *dr, char *st)
{
	tree *dr1, *dr2;
	dr1 = (tree *)malloc(sizeof(tree));  // создание нового элемента(узла) добавляемого в дерево
	dr1->inf = (char *)malloc(strlen(st) + 1);  
	strcpy(dr1->inf, st);                // ввод информации в этот новый элемент
	dr1->n = 0; 
	dr1->L = dr1->R = nullptr;
	if(!dr) return dr1;       // если дерево пустое (dr==nullptr если в дерево еще не было ввода инф.)
	else                      // иначе поиск места в дереве куда добавляется новый элемент
	{
		dr2 = dr;        
		while(dr2)            // dr2-указатель "пробегает" по дереву до искомого узла или до конца ветви
		{
			if(strcmp(dr1->inf, dr2->inf) == 0)  // в дереве найдена искомая информация
			{                                    // т.е. узел с такой информацией уже в дереве есть
				dr2->n++;                        // увеличивается счетчик в найденном узле,       
				free(dr1->inf); free(dr1); break;// а dr1 не добавляется как новый элемент 
			}
			else              // в узле dr2 дерева информациея не совпадает с искомой
			if(strcmp(dr1->inf, dr2->inf)<0)  // dr1->inf меньше dr2->inf  
			  if(dr2->L == nullptr)           // из вершины dr2 нет движения влево 
			  { dr2->L = dr1;                 // вставка узла dr1 в дерево
			    dr2 = nullptr;                // для выхода из цикла while
			  }
			  else dr2 = dr2->L;              // переход к следующей вершине дерева слева от dr2
			else                              // иначе: dr1->inf больше dr2->inf 
			  if(dr2->R == nullptr)           // из вершины dr2 нет движения вправо 
			  { dr2->R = dr1;                 // вставка узла dr1 в дерево
			    dr2 = nullptr;                // для выхода из цикла while
			  }
			  else dr2 = dr2->R;              // переход к следующей вершине дерева справа от dr2
		}
	}
	return dr;
}

//  рекурсивное создание бинарного дерева
tree* creat2(tree *dr, char* st)
{
	if (!dr)     // это условие, что при движении по дереву выход за лист
	{            // т.е.  st не найдено в дереве
		dr = (tree *)malloc(sizeof(tree));   // создание нового элемента(узла), вводимого в дерево
		dr->inf = (char *)malloc(strlen(st) + 1); 
		strcpy(dr->inf, st);                 // ввод информации в этот новый элемент 
		dr->n = 0;                           // число повторов ввода информации в узел дерева
		dr->L = dr->R = nullptr;             // это новый лист
	}
	else if (strcmp(st, dr->inf) == 0) dr->n++;          // информация уже есть в дереве
	     else if (strcmp(st, dr->inf)<0) dr->L = creat2(dr->L, st); // иначе движение влево
	          else dr->R = creat2(dr->R, st);                       // движение вправо
	return dr;
}

// рекурсивный вывод содержимого бинарного дерева
void show_1(tree *dr)
{
	if (dr)
		// для вывода информации удалите комментарий с одной
		// из инструкций printf  содержащихся ниже
	{   // printf("узел содержит :   %s , число встреч %d\n",dr->inf,dr->n);
		if (dr->L) show_1(dr->L);     // вывод левой ветви дерева
		// printf("узел содержит :   %s , число встреч %d\n",dr->inf,dr->n);
		if (dr->R) show_1(dr->R);     // вывод правой ветви дерева
		// printf("узел содержит :   %s , число встреч %d\n", dr->inf, dr->n);
	}
}

// нерекурсивный вывод содержимого бинарного дерева
// используя стек для занесения адресов узлов дерева
void show_2(tree *dr1)
{
	struct stack    // стек узлов дерева через которые осуществляется движение по ветви 
	{	tree *d;            // узел дерева  
		stack *s;           
	} *st, *st1 = nullptr;

	if (!dr1) { printf("бинарное дерево пустое\n"); return; }
	int pr = 1;            // 1 - признак движения влево по ветви дерева
                                         	// в стек заносится элемент содержащий указа-
	st = (stack *)calloc(1, sizeof(stack)); // тель на корень дерева для прохода по
	st->d = dr1;                            // левому и правому поддеревьям
	st->s = st1;                            // указатель на предыдущий эл-т стека 
	printf("узел содержит :   %s , число встреч %d\n", dr1->inf, dr1->n);
	while (st || dr1->R)  // пока стек не пустой и есть движение вправо по дереву
	{
		do  // цикл - пока не лист дерева
		{
			if(pr && dr1->L) dr1 = dr1->L;  // переход на узел слева
			else if(dr1->R) dr1 = dr1->R;   // переход на узел cправа
			pr = 1;                   // сброс принудительного движения вправо
			if(dr1->L && dr1->R)      // узел с 2 связями (вниз по дереву)
			{
				st1 = st;               // запоминаем вершину стека
				st = (stack *)calloc(1, sizeof(stack)); // новый эл-т стека
				st->d = dr1;            // указатель на найденый узел дерева
				st->s = st1;            // указатель из вершины стека на предыдущий 
			}
			printf("узел содержит :   %s , число встреч %d\n", dr1->inf, dr1->n);
		} while(dr1->L || dr1->R);
		if (st)                      // стек не пустой
		{                            // с вершины стека считываем узел(ветвления) дерева 
			dr1 = st->d;             // для возврата на этот узел ветвления в дереве
			st1 = st->s;             // указатель вниз на следующий элемент стека
			free(st);                // удаление из стека указателя на выбранный узел
		}     		                
		st = st1;                    // запоминаем новую вершину стека
		if (dr1->L && dr1->R) pr = 0;   // это узел ветвления, устанавливаем признак принудительного 
		else break;                     // перехода на узел расположенный справа от dr1, т.к.
	                                    // dr1->inf уже выведен при проходе слева
	}
}

//  псевдографический вывод содержимого бинарного дерева
void print(tree* dr, int level)
{
	if (dr) print(dr->R, level + 1); //
	for (int n = 0; n<level; ++n) printf("   ");
	if (dr) printf("%s (%d)\n", dr->inf, dr->n);
	else printf("@\n");
	if (dr) print(dr->L, level + 1); //
}

// функция удаления узла бинарного дерева
tree* erase(tree *dr)
{
	tree *dr1, *dr2, *dr3;
	char *st;                 // строка для анализа информации
	int k;                    // результат сравнения двух строк
	int ind;
	if (!dr)
	{
		puts("бинарное дерево пустое\n");
		return NULL;
	}
	puts("Введите информацию в для поиска удаляемого узла");
	st = (char *)malloc(sizeof(char)*N);
	fflush(stdin);
	gets(st);                 // строка для поиска узла в дереве
	if (!*st) return NULL;    // выход в функцию  main при вводе пустой строки
	dr2 = dr1 = dr;           // dr1 и dr2 устанавливаются на корень дерева
	ind = 0;                  // 1 - признак выхода из цикла поиска
	do                        // цикл поиска удаляемого из дерева узла dr1
	{
		if (!(k = strcmp(st, dr1->inf)))
			ind = 1;          // удаляемый узел со строкой st найден
		if (k<0)              // введ. строка  <  строки в анализируемом узле
		{
			if (dr1->L)       // движение налево из узла dr1 существует
			{
				dr2 = dr1;    // запоминаем текущий узел
				dr1 = dr1->L; // считываем новый левый узел дерева
			}
			else ind = 1;     // выход из цикла do ... while при ненахождении информации в дереве
		}
		if (k>0)          // введ. строка  >  строки в анализируемом узле
		{
			if (dr1->R)
			{
				dr2 = dr1;      // запоминаем текущий узел
				dr1 = dr1->R;   // считываем новый правый узел дерева
			}
			else ind = 1;     // выход из цикла do ... while при ненахождении информации в дереве
		}
	} while (!ind);
	free(st);
	if (k)
	{
		puts("Требуемый узел не найден \n");
		getch();
		return dr;
	}
	else
	{
		k = strcmp(dr1->inf, dr2->inf);
		dr3 = dr1;             // запоминаем удаляемую вершину дерева
		if (k<0)               // удаляемая вершина < предыдущей
		{
			if (dr1->R)           // у вершины dr1 есть ветвь вправо
			{
				dr3 = dr1->R;     // переход на вершину вправо от удаляемой и далее
				while (dr3->L) dr3 = dr3->L; // поиск вершины с nullptr влево
				dr2->L = dr1->R;  // обход удаляемой вершины dr1
				dr3->L = dr1->L;
			}
			else dr2->L = dr1->L; // просто удаление вершины dr1, не имеющей правой связи
		}
		else                  // удаляемая вершина > предыдущей
		{
			if (dr1->L)          // у вершины dr1 есть ветвь вправо
			{
				dr3 = dr1->L;        // переход на вершину влево от удаляемой и далее
				while (dr3->R) dr3 = dr3->R;// поиск вершины с nullptr вправо
				dr2->R = dr1->L;    // обход удаляемой вершины dr1
				dr3->R = dr1->R;
			}
			else dr2->R = dr1->R;  // просто удаление вершины dr1, не имеющей левой связи
		}
		free(dr1->inf); free(dr1);
	}
}



