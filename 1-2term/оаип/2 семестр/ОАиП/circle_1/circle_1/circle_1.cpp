// Пример работы с однонаправленным кольцом (списком коьцевого типа) 
// элемент кольца имеет один указатель на соседний элемент
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <locale.h>
struct node
{
	char inf[50];  // информационное поле
	node *nx;      // указатель на следующий элемент кольца (списка)
};

void show(node *);
void sozd(node **);
node *del(node *);
node *del_any(node *);
void srt(node *);
void srt_uk(node **);

int main()
{
	setlocale(LC_ALL, "Russian");
	node *h;              // указатель на 'начальный' элемент кольца ("точка входа")
	h = nullptr;          // кольца нет
	char l;
	while (1)
	{
		puts("вид операции: 1-создать кольцо");
		puts("              2-вывод содержимого кольца");
		puts("              3-удаление элемента из кольца");
		puts("              4-удаление любого элемента из кольца");
		puts("              5-сортировка (изменяя указатели на элементы)");
		puts("              6-сортировка (изменяя содержимое элементов)");
		puts("              0-выход");
		fflush(stdin);
		switch (getch())
		{
		case '1': sozd(&h); break;
		case '2': show(h); break;
		case '3': h = del(h); break;
		case '4': h = del_any(h); break;
		case '5': if (h) srt_uk(&h); break;
		case '6': if (h) srt(h); break;
		case '0': return 0;
		}
	}
	return 0;
}

// функция создания/добавления в кольцо
// добавление выполняется вправо от элемента входа в кольцо
void sozd(node **h)
{
	node *s1, *s2;
	if (!*h)                // кольцо еще создано (т.е. не содержит ни одного элемента) 
	{
		if (!(s1 = (node *)malloc(sizeof(node))))
		{                    // создаем первый элемент для создания кольца
			puts("Нет свободной памяти");
			return;
		}
		puts("Введите информацию в inf");
		scanf("%s", s1->inf);
		s1->nx = s1;         // "замыкаем" единственный элемент на себя 
		*h = s1;             // указатель на кольцо пока с единственным эл-том
	}
	else s1 = (*h)->nx;      // кольцо уже существует, s1 - указатель на след. эл-т от точки входа
	do
	{
		if (!(s2 = (node *)malloc(sizeof(node))))
		{                    // создаем элемент для добавления его в кольцо
			puts("Нет свободной памяти");
			return;
		}
		puts("Введите информацию в inf");
		scanf("%s", s2->inf);
		// новый элемент добавляется в кольцо справа от точки входа *h
		// вставляем элемент между эл-тами *h и s1
		s2->nx = s1;         // s2->nx теперь указывает на  элемент s1
		s1 = s2;             // указатель s1 передвигаем на s2 (для добавления следующего эл-та)
		puts("Продолжить (y/n): ");
		fflush(stdin);
	} while (getch() == 'y');
                             // если цикл ввода новых эл-тов в кольцо окончен, то сообщаем
	(*h)->nx = s2;           // точке входа адрес элемента расположенного справа 
}

// функция вывода содержимого кольца, обход кольца
// выполняется по выбору либо справа налево, либо слева направо 
void show(node *s)
{
	node *s1;
	char p;
	if (!s)
	{
		puts("Кольцо пустое");
		return;
	}
	s1 = s;                        // указатель движения по кольцу на точку входа 
	fflush(stdin);
	do
	{
		printf("%s\n", s1->inf); // вывод содержимого элемента кольца
		s1 = s1->nx;             // переход к следующему элементу кольца
	} while (s1 != s);           // выполнен обход кольца      
	puts("Вывод кольца закончен");
	return;
}

// функция удаления элемента кольца с точки входа
// указатель на точку входа смещается вправо
node *del(node *s)
{
	node *s1;
	if (!s)
	{
		puts("Кольцо пустое"); return s;
	}
	s1 = s->nx;           // s1 - указатель на элемент расположенный справа от точки входа 
	if (s->nx == s)       // узел в кольце один
	{
		free(s); return nullptr;
	}
	else
	{
		while (s1->nx != s) s1 = s1->nx; // остановка на элем. предшествующем точке входа
		s1->nx = s->nx;    // исключение (обход) узла s (точка входа) из кольца
		free(s);           // удаление узла s (точка входа) из кольца 
		return s1->nx;         // новая точка входа в кольцо
	}
}

// функция поиска и удаления элемента в СПИСКЕ имеющим
// огранизацию однонаправленное кольцо
node *del_any(node *s)
{
	node *s1;                       // указатель на удаляемый элемент кольца
	node *s2;
	char *in;
	in = (char *)calloc(50,sizeof(char));
	if (!in) return s;

	if (!s)
	{
		puts("Кольцо пустое"); return s;
	}
	puts("Введите информацию о удаляемом узле");
	fgets(in,49,stdin);
	s1 = s;
	while (s1->nx != s) s1 = s1->nx; // остановка на элем. предшествующем точке входа
	do                               // цикл просмотра содержимого кольца
	{
		if (strcmp(s1->nx->inf, in)) s1 = s1->nx; // s1->nx не элемент для удаления
		else                         // найден элемент кольца для удаления
		{
			if (s1->nx == s1)         // в кольце всего один элемент 
			{
				free(s1); return nullptr;
			}
			if (s1->nx==s) s = s->nx; // новая точка входа в кольцо, т.е. если удаляемый
			                          // элемент на точке входа, то смещаем ее вправо
			s2 = s1->nx;              // указатель на удаляемый элемент списка
			s1->nx = s2->nx;          // исключение узла s2 из кольца
			free(s2);                 // удаление элемента кольца s1		
			return s;
		}
	} while (s1->nx != s);               // пока не выполнен обход кольца
	printf("Записи с информацией = %s в кольце нет \n", in);
	return s;
}

// сортировка информации в СПИСКЕ имеющим огранизацию
// двунаправленное кольцо, перемещением содержимого
void srt(node *s)
{
	node *s1,       // указатель на элемент выбранный к сортировке
		 *s2,       // указатель "бегунок" по списку
		 *s3;       // указатель на найденный элемент к замене
	char a[50], c;
	int i;
	s1 = s;                // исходный элемент списка для замены
	do
	{
		s3 = s2 = s1;                 // вначале s1, s2 и s3 совпадают
		do
		{
			s2 = s2->nx;              // переход по списку к сравнению следующего элемента
			if (strcmp(s3->inf, s2->inf)>0) // найден элемент (в s2) мельший контрольного (s3)
			   s3 = s2;               // запоминаем адрес элемента списка с меньшим значением

		} while (s2->nx != s);            // s2 обошло весь список
		if (s1 != s3)
		{
			strcpy(a, s1->inf);   // замена содержимого s1 <--> s3
			strcpy(s1->inf, s3->inf); 
			strcpy(s3->inf, a);
		}
        s1 = s1->nx;                  // выбираем новый элемент для упорядочивания
	} while (s1->nx != s);            // s1 прошло по списку до точки входа
}


// сортировка информации в СПИСКЕ имеющим огранизацию
// двунаправленное кольцо, изменением указателей
void srt_uk(node **s)
{
	node *s1, *s2,
		 *s3, *s4,
	     *s5, *s6;
	s1 = *s;                                 // s1 указатель на точку входа, указатель на элемент,
	                                         // далее используемый как исходный для упорядочивания
	s2 = s1->nx;
	while (s2->nx!=*s) s2 = s2->nx;          // s2 указатель предшествующий s1
	do
	{	
		s3 = s1->nx;                             // указатель для поиска в списке элемента с меньшим значением
	    s4 = s1;                                 // указатель на элемент расположенный перед элементом s3 
		s5 = s1;                                 // указатель на контрольный (меньший) элемент
		do
		{
			if (strcmp(s5->inf, s3->inf) > 0)  // сравнение текущего (s3) элемента с контрольным (s5)
			{
				s5 = s3;                     // если в s3 меньшее значение чем в s5 - запоминаем s3
				s6 = s4;                     // s6 перед s5
			}
			s3 = s3->nx;                     // движение s3  и s4 по списку дальше
			s4 = s4->nx;                     
		} while (s3 != *s);                  // цикл пока список не просмотрен
		if (s5 != s1)                        // указатель s5 сместился с s1 (след-но найдено меньшее значение)
		{                            // блок замены s1  замена          
			if (*s == s1) *s = s5;   // корректировка адреса входа в кольцо (если в нем было не меньшее значение)
			
			s2->nx = s5;             // s5 "становится" между s2 и s1 
			s6->nx = s5->nx;         // "обходим" элемент s5 
			s5->nx= s1;              // s5 указывает на s1
			s2 = s5;                 // s2 опять перед s1;
		}
		else                         // для s1не найдено меньшее
		{
			s1 = s1->nx;             // выбор следующего элемента к сортировке
			s2 = s2->nx;             // s2 перед ним
		}
		show(*s);
	} while (s1->nx != *s);
}





