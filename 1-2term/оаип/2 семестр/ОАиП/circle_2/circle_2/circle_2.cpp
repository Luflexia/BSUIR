// Пример работы с двунаправленным кольцом (списком коьцевого типа) 
// элемент кольца имеет два указателя на элементы (спава и слева)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <locale.h>
struct node
{
	char inf[50];  // информационное поле
	node *l;       // указатель на предыдущий элемент (налево)
	node *r;       // указатель на следующий элемент  (направо)
};

void show(node *);
void sozd(node **);
node *del(node *);
node *del_any(node *);
void srt(node *);
node *srt_uk(node *);
node *napr(char c, node * s);

int main()
{
	setlocale(LC_ALL, "Russian");
	node *h;              // указатель на 'начальный' элемент кольца ("точка входа")
	h = nullptr;          // кольца нет
	char l;
	while (1)
	{
		puts("вид операции: 1-создать кольцо");
		puts("              2-вывод содержимого кольца");
		puts("              3-удаление элемента из кольца");
		puts("              4-удаление любого элемента из кольца");
		puts("              5-сортировка (изменяя указатели на элементы)");
		puts("              6-сортировка (изменяя содержимое элементов)");
		puts("              0-выход");
		fflush(stdin);
		switch (getch())
		{
		case '1': sozd(&h); break;
		case '2': show(h); break;
		case '3': h=del(h); break;
		case '4': h=del_any(h); break;
		case '5': if (h) h = srt_uk(h); break;
		case '6': if (h) srt(h); break;
		case '0': return 0;
		}
	}
	return 0;
}

// функция создания/добавления в кольцо
// добавление выполняется вправо от элемента входа в кольцо
void sozd(node **h)
{
	node *s1, *s2;
	if (!*h)                // кольцо еще создано (т.е. не содержит ни одного элемента) 
	{
		if (!(s1 = (node *)malloc(sizeof(node))))
		{                    // создаем первый элемент для создания кольца
			puts("Нет свободной памяти");
			return;
		}
		puts("Введите информацию в inf");
		scanf("%s", s1->inf);
		s1->l = s1->r = s1;  // "замыкаем" единственный элемент на себя 
		*h = s1;             // указатель на кольцо пока с единственным эл-том
	}
	else s1 = (*h)->r;       // кольцо уже существует, s1 - указатель на право от точки входа
	do
	{ 
		if (!(s2 = (node *)malloc(sizeof(node))))
		{                    // создаем элемент для добавления его в кольцо
			puts("Нет свободной памяти");
			return;
		}
		puts("Введите информацию в inf");
		scanf("%s", s2->inf);
		                     // новый элемент добавляется в кольцо справа от точки входа
		                     // вставляем элемент "разрывая" всязь от s1 к h
		s1->l = s2;          // s1->l теперь указывает (налево) на новый s2 элемент
		s2->r = s1;          // s2->r указывает (направо) на элемент s1
		                     // т.е. s2 вставился между h и s1 (и стал как бы справа от h)
		s1 = s2;             // указатель s1 передвигаем на s2 (для добавления следующего эл-та)
		puts("Продолжить (y/n): ");
		fflush(stdin);
	} while (getch() == 'y');
	                         // если цикл ввода новых эл-тов в кольцо окончен, то
	s2->l = *h;              // устанавливаем связь налево последнего добавленного в кольцо 
	                         // эл-та s2 с точкой входа в кольцо h
	(*h)->r = s2;            // сообщаем точке входа адрес элемента расположенного справа
}

// функция вывода содержимого кольца, обход кольца
// выполняется по выбору либо справа налево, либо слева направо 
void show(node *s)
{
	node *s1;
	char p;
	if (!s)
	{  puts("Кольцо пустое"); 
	   return;
	}
	s1 = s;                        // указатель движения по кольцу на точку входа 
	puts("r - по часовой, l - против часовой\n");
	fflush(stdin);
	switch (p = getch())
	{
      case 'r': case 'R':
	  case 'l': case 'L':
		do
		{
			printf("%s\n", s1->inf); // вывод содержимого элемента кольца
			s1 = napr(p, s1);        // переход к следующему элементу кольца
		} while (s1 != s);           // выполнен обход кольца      
		break;
	}
	puts("Вывод кольца закончен");
	return;
}

// функция удаления элемента кольца с точки входа
// указатель на точку входа смещается вправо
node *del(node *s)
{
	node *s1;
	if (!s)
	{
		puts("Кольцо пустое"); return s;
	}
	s1 = s->r;           // s1 - указатель на элемент расположенный справа от точки входа 
	if (s->r == s)       // узел в кольце один
	{
		free(s); return nullptr;
	}
	else
	{
		s->l->r = s1;    // исключение узла s из кольца
		s1->l = s->l;
		free(s);         // удаление узла s1
		return s1;           // новая точка входа в кольцо
	}
}

// функция поиска и удаления элемента в СПИСКЕ имеющим
// огранизацию двунаправленное кольцо
node *del_any(node *s)
{
	node *s1;                       // указатель на удаляемый элемент кольца
	char in[50];
	if (!s)
	{
		puts("Кольцо пустое"); return s;
	}
	s1 = s;
	puts("Введите информацию о удаляемом узле");
	scanf("%s", in);
	do                              // цикл просмотра содержимого кольца
	{
		if (strcmp(s1->inf, in)) s1 = s1->r; // не элемент для удаления
		else                       // найден элемент кольца для удаления
		{
			if (s1->r == s1)       // в кольце всего один элемент 
			{
				free(s1); return nullptr; 
			}
			if (s == s1) s = s->r; // новая точка входа в кольцо, т.е. если удаляемый
			                       // элемент на точке входа, то смещаем ее вправо
			s1->l->r = s1->r;      // исключение узла s1 из кольца
			s1->r->l = s1->l;
			free(s1);              // удаление элемента кольца s1
			return s;              
		}
	} while (s1!=s);               // пока не выполнен обход кольца
	printf("Записи с информацией = %s в кольце нет \n", in);
	return s;
}

// сортировка информации в СПИСКЕ имеющим огранизацию
// двунаправленное кольцо, перемещением содержимого
void srt(node *s)
{
	node *s1, *s2;
	char a[50], c;
	int i;
	puts("направление r - по часовой, l - против часовой\n");
	fflush(stdin);
	c = getch();
	s1 = s;                           // исходный элемент списка для замены
	do
	{
		strcpy(a, s1->inf);           // исходная информация для замены (из s1)
		s2 = s1;                      // указатель "бегунок" по списку
		do
		{
			s2 = napr(c, s2);         // выбор элемента для сравнения
			if (strcmp(a, s2->inf)>0) // найден элемент (в s2) мельший выбранного (s1)
			{
				strcpy(s1->inf, s2->inf); // замена содержимого s1 <--> s2
				strcpy(s2->inf, a);
				strcpy(a, s1->inf);
			}
		} while (napr(c, s2) != s);   // s2 обошло весь список
		s1 = napr(c, s1);             // выбираем новый элемент для упорядочивания
	} while (napr(c, s1) != s);       // s1 прошло по списку до точки входа
}

// сортировка информации в СПИСКЕ имеющим огранизацию
// двунаправленное кольцо, изменением указателей
node *srt_uk(node *s)
{
	node *s1, *s2, *s3;
	int i;
	s1 = s;                                  // указательна элемен, выбранный для упорядочивания
	do
	{
		s2 = s1->r;                          // указатель "бегунок" по списку
		s3 = s1;                             // указатель для запоминания найденного элемента "лучшего" s1
		do
		{
			if (strcmp(s3->inf, s2->inf)>0)  // сравнение текущего (s2) элемента с контрольным (s3)
				s3 = s2;                     // если в s2 меньшее значение чем в s3 - запоминаем s2
			s2 = s2->r;                      // движение s2 по списку вправо
		} while (s2 != s);                   // цикл пока список не просмотрен
		if (s3 != s1)                        // указатель s3 сместился с s1 (след-но найдено меньшее значение)
		{                          // замена          
			if (s == s1) s = s3;   // корректировка адреса входа в кольцо (если в нем было не меньшее значение)
			s3->l->r = s3->r;      // исключение элемента s3 из списка
			s3->r->l = s3->l;      // ----------
			s1->l->r = s3;         // вставка элемента s3 в список перед s1 (слева)
			s3->r = s1;            // ----------
			s3->l = s1->l;         // ----------
			s1->l = s3;            // ----------
		}
		else
			s1 = s1->r;
	} while (s1->r != s);
	return s;
}

// функция выбора следующего элемента кольца (списка)
// в зависимости от выбранного направления обхода
node *napr(char c, node *s)
{
	switch (c)
	{
      case 'r': case 'R': return s->r;   // вправо
      case 'l': case 'L': return s->l;   // влево
	}
}
