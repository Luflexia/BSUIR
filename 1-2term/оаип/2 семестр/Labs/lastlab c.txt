#include <queue>
#include <stdlib.h>
#include <io.h>
#include <stdio.h>
#include <iostream>

struct node //структура дерева
{
	int num = 1;// количество повторенний элемента в этой ветви
	int data;//элемеент хранящийся в этой ветви
	struct node* right;//указатель на правую ветвь
	struct node* left;//указатель на левую ветвь
};

node* newnode(int dat)//функция инициализации новой ветви
{
	node* newn = (node*)malloc(sizeof(node));//выделем память под новую ветвь

	newn->data = dat;//инициализируем данные этой ветви
	newn->num = 1;//по стандарту кол-во повторений ставим 1
	newn->left = newn->right = NULL;//делаем указатели левой и правой ветвей NULL чтоб не тратить лишнюю память под незадействованные ветви
	return(newn);//возвращаем созданную и инициализированную ветвь//
}

node* insert(node* root, int data)// функция ввода данных в дерево
{
	if (root == NULL)//проверяем была ли ветвь инициализированна
	{
		root = newnode(data);//если нет то инициализируем
		return root;//и возвращаем значение новой ветви
	}
	else if (root->data > data)//если данные в ветви больше поданных данных
	{
		root->left = insert(root->left, data);//то заносим поданные данные в левую ветвь
	}
	else if (root->data < data)//если же данные в этой ветвим меньше поданных
	{
		root->right = insert(root->right, data);// то заносим в правую ветвь
	}
	else if (root->data == data)// если же они равны, то увеличиваем счетчик num на единицу, чтоб показать то, что у нас два таких элемента
	{
		root->num++;//увеличиваем счетчик
	}
	return root;//возвращаем ветвь
}


void out(node* r1, char r)//функция вывода дерева
{
	if (r1 == NULL)//если ветка не была инициализированна то выходим из функции
	{
		return;//выход из функции
	}
	if (r1->data)//если данные были инициализированы
	{
		printf_s("%c:", r) ;//выводим символ обозначающий к какой части дерева относится переменная хранящаяся в ветви
		printf_s("%d", r1->data);//вывод саму переменную
	}

	out(r1->left, 'l');// рекурсивно вызываем это же действие для левой и правой ветвей
	// такой вызов позволит перебрать все ветви пока мы не дойдем до конца дерева
	out(r1->right, 'l');

}

int main() //думаю тут уже комент не нужен
{
	queue <int> que; //по условию создаем очередь

	struct node* root = NULL; //создаем дерево
	int n;// переменная для задания размера очереди и дерева
	int mp;// переменная для ввода переменных очереди
	printf_s("Enter number of elements: ");
	scanf_s("%d", n);//ввод размера очереди\дерева
	for (int i = 0; i < n; i++)
	{
		scanf_s("%d", mp);//считываем переменную
		que.push(mp);// и закидываем ее в очередь
	}

	int* arr = (int*)malloc(n);//динамически объявляем массив нужного размера(такого же размера как и очередь)

	for (int i = 0; i < n; i++)//переносим переменные из очереди в массив, т.к. очередь не имеет алоритма сортировки и такая сортировка является самой простой
	{
		arr[i] = que.front();//берем первую переменную и заносим в массим, т.к. очередь работает по приципу LILO - last in last out т.е. последний вошел, последний вышел
		que.pop();//удаляем считанную переменную
	}

	for (int i = 0; i < n - 1; i++)//сортируем массив для того что бы правильно построить сбланасированное дерево
	{
		for (int j = i + 1; j < n; j++)
		{
			if (arr[i] < arr[j]) { swap(arr[i], arr[j]); }//команда swap меняет местами 2 поданных в нее аргумента}
		}
	}
	root = insert(root, arr[n / 2]);//заносим в корень центральный элемент отсортированного массива, чтоб слева и справа от него в дереве была примерно одинаковая глубина(условие сбалансированного дерева это то что глубина на левой и правой ветви отличается не более чем на 1)
	for (int i = 0; i < n / 2; i++)//вносим левую половину дерева. по частям вносим чтоб немного ускорить его заполнение и чтоб корневой элемент не подавался дважды
	{
		root = insert(root, arr[i]);//функция подачи элемента в дерево
	}
	for (int i = n / 2 + 1; i < n; i++) //вносим правую половину дерева
	{
		root = insert(root, arr[i]);
	}
	out(root->left, 'l');//выводим левую половину дерева с символом l(left)
	printf_s("h: %d ", root->data);//выводим корень дерева с символом h(head)
		out(root->right, 'r');//выводим правую половину с символом r(right)
	system("pause");//делаем небольшую системную паузу чтоб пользователь смог ознакомиться с результатом
}