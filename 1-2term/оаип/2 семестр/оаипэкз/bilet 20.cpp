//Ѕилет 20
//ќрганизовать ввод информации в массив, организованный по принципу бинарного дерева (дл€ k-ого элемента: если левое поддерево, то сделать 2k, если правое, то 2k + 1).
//“ут мы создадим два массива, один как написано в задании, а во втором мы будем запоминать на каких позици€х есть значени€

void add(int** derevo, int& numeretic, bool** set) {     // это основна€ функци€, котора€ добавл€ет в массив числа

    int enter_number;// это число которое мы вводим
    printf("enter data: ");
    check_num(enter_number);


    int k = 1;// это наш индекс который будет измен€тьс€ и мы с помощью него будем определ€ть место куда надо вставить
    while (1) {

        if (k > numeretic) {// если надо добавить в €чейку с индексом большим чем размер массива
            numeretic = k;// присваиваем размеру массива новое значение
            (*derevo) = (int*)realloc((*derevo), (numeretic + 1) * sizeof(int));    // измен€ем пам€ть массивов


            (*set) = (bool*)realloc((*set), (numeretic + 1) * sizeof(bool));// этот массив смотрит в каких €чейках есть информаци€(если нету то true, если есть то false)
            continue;
        }

        if ((*derevo)[k] == enter_number) {// если мы введЄм значение которое уже есть в массивае то мы просто увидем сообщение и выйдем из функции
            printf("number already exist!\n");
            system("pause");
            return;
        }

        if ((*set)[k]) {// если можно вставить в €чейку с индексом k
            (*derevo)[k] = enter_number;// присваиваем значение €чейке
            (*set)[k] = false;// присваиваем значение чтобы знать что в €чейке k есть информаци€
            break;
        }
        else if (enter_number < (*derevo)[k]) {// если введЄнное число меньше чем элемент массива(как в левой части дерева) то мы переходим на €чейку 2*k(чЄтное)
            k *= 2;
            continue;
        }
        else {
            k = k * 2 + 1;// если введЄнное число больше чем элемент массива(как в правой части дерева) то мы переходим на €чейку 2*k+1(нечЄтное)
            continue;
        }
    }
}

int main() {
    int* derevo, numeretic = 1;// derevo - основной массив, numeretic - размер массива
    bool* set;// дополнительный массива дл€ определени€ записано ли число

    derevo = (int*)malloc((numeretic + 2) * sizeof(int));// выдел€ем пам€ть (+2 так как мы будем записывать с 1)(не +1 так на вс€кий)

	if (!derevo) {
		exit(error);
	}

    set = (bool*)malloc((numeretic + 2) * sizeof(bool));

        if (!set) {
		exit(error);
	}
        add(&derevo, numeretic, &set);
       return 0;
}