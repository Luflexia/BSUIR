// ниже приведен пример работы с двумерным массивом (матрицей)
// используя УКАЗАТЕЛЬ на УКАЗАТЕЛЬ. Работа с матрицей осущесвляется
// с использованием рекурсивных функций
#include <stdio.h>
#include <conio.h>
#include <locale.h>
#include <windows.h>
#include <stdlib.h>

void swap(int **, int, int, int, int);
void Poisk(int **, int, int);

// рекурсивная функция ввода матрицы
int Vvod(int **MS, int n_str, int n_stl)
{
	static short int i, j;
	if (!MS)                              // проверка не нулевой ли указатель
	{
		puts("память для массива (матрицы) не выделена");
		return 1;
	}	
	if (j >= n_stl)                       // очередная строка матрицы введена
	{
		i++;                              // переходим к новой строке
		j = 0;                            // становимся в начало этой (новой) строки
	}
	if (i >= n_str) return 0;             // матрица успешно введена (введено n_str полных строк)
	printf("MS[ %d ][ %d ] = ", i, j);
	fflush(stdin); //rewind(stdin);       // чистка входного буфера
	if (scanf("%d", *(MS + i) + j)) j++;  // проверка введено ли число, если ввод успешный	                                       // то переходим к следующему элементу(столбцу) строки
	Vvod(MS, n_str, n_stl);               // рекурсивный вызов функции для ввода очередного эл-та
	return 0;
}

// рекурсивная функция вывода матрицы на экран
void Print(int **MS, int n_str, int n_stl)
{
	static short int i, j;
	if (!i && !j) printf("\n");
	if (!MS)                           // проверка не нулевой ли указатель
	{
		puts("память для массива (матрицы) не выделена");
		return;
	}
	if (j >= n_stl)                    // очередная строка матрицы выведена
	{
		i++;                           // переходим к новой строке
		j = 0;                         // становимся в начало этой (новой) строки
		printf("\n");                  // вывод с новой строки
	}
	if (i >= n_str)                    // матрица успешно выведена (введено n_str полных строк)
	{  
		i = j = 0;
		printf("\n");
		return;
	}
	printf("%4d", *(*(MS + i) + j++));
	Print(MS, n_str, n_stl);
	
}

////--------------------------------------------- пример 1 -----------------------------------
//// пример работы с двухмерным массивом через указатель на указатель
//// найти под главной диагональю max и min эл-ты и поменять их местами
//int main()
//{
//	setlocale(LC_ALL, "Russian");
//	int **p = nullptr, n, s, i, j, j1, j2, sum1, sum2, sum;
//	do
//	{
//		system("CLS");
//		printf("\nвведите размерность квадратной матрицы\n");
//		i = scanf("%d", &n);
//		if (i < 1)
//		{
//			fflush(stdin);  // чистка буффера клавиатуры при ошибке ввода
//			continue;       // повтор цикла
//		}
//		s = n;             // матрица квадратная (число строк=числу столбцов)
//		if (!(p = (int **)malloc(sizeof(int*)*n)))
//			printf("\nНедостаточно свободной памяти \nУуменьшите число строк матрицы");
//		for (i = 0; i < n; i++) // цикл выбора указателя на строку матрицы
//		if (!(*(p + i) = (int *)malloc(sizeof(int)*s))) // выделение памяти под строку матрицы
//		{                                               // с проверкой выделена ли память
//			printf("\nНедостаточно свободной памяти \nУуменьшите число ст-цов матрицы");
//			for (j = 0; j < i; j++) free(*(p + j)); free(p); // освобождение памяти при ошибке
//			p = nullptr;   // сброс указателя для повтора операции выделения памяти
//			break;         // выход из цикла по i (выбора указателя на строку матрицы)
//		}
//	} while (!p);
//
//	Vvod(p, n, s);
//	system("CLS");
//	printf("\nВведенная матрица");
//	Print(p, n, s);
//	Poisk(p, n, s);
//	printf("\n\nПреобразованная матрица");
//	Print(p, n, s);
//	for (i = 0; i<n; i++)  free(*(p + i));// освобождение памяти на которую указывает p[i]  
//	free(p);                              // освобождение памяти на которую указывает p               
//	return 0;
//}
//
//void Poisk(int **MS, int n_str, int n_stl)
//{
//	static short int i=1, j, imin=i, jmin=j, imax=i, jmax=j;
//	if (!MS)                           // проверка не нулевой ли указатель
//	{
//		puts("память для массива (матрицы) не выделена");
//		return;
//	}
//	if (j >= i)                        // очередная строка матрицы проанализирована
//	{                                  // ДО ДИАГОНАЛИ
//		i++;                           // переходим в новой строке
//		j = 0;                         // становимся в начало этой (новой) строки
//	}
//	if (i >= n_str)                    // анализ матрица выполнен (просмотрено n_str полных строк )
//	{
//		if (imin != imax || jmin != jmax) swap(MS, imin, jmin, imax, jmax);
//		i = 1; j = 0;                  // для возможного повторного поиска
//		return;    
//	}
//	if (*(*(MS + i) + j) > *(*(MS + imin) + jmin))
//	{
//		imin = i; jmin = j;
//	}
//	else
//	if (*(*(MS + i) + j) < *(*(MS + imax) + jmax))
//	  {
//		imax = i; jmax = j;
//	  }
//	j++;
//	Poisk(MS, n_str, n_stl);
//}

// функция ( не рекурсивная) замены найденных эл-тов в матрице
void swap(int **ms, int i1, int j1, int i2, int j2)
{
	int tmp;           
	tmp = ms[i1][j1];
	ms[i1][j1] = ms[i2][j2];
	ms[i2][j2] = tmp;
}



//--------------------------------------------- пример 2 -----------------------------------
// выполниьть транспонирование квадратной матрицы используя рекурсивную функцию
void Transp(int **, int);

int main()
{
	setlocale(LC_ALL, "Russian");
	int **p = nullptr, n, s, i, j, j1, j2, sum1, sum2, sum;
	do
	{
		system("CLS");
		printf("\nвведите размерность квадратной матрицы\n");
		i = scanf("%d", &n);
		if (i < 1)
		{
			fflush(stdin);  // чистка буффера клавиатуры при ошибке ввода
			continue;       // повтор цикла
		}
		s = n;             // матрица квадратная (число строк=числу столбцов)
		if (!(p = (int **)malloc(sizeof(int*)*n)))
			printf("\nНедостаточно свободной памяти \nУуменьшите число строк матрицы");
		for (i = 0; i < n; i++) // цикл выбора указателя на строку матрицы
		if (!(*(p + i) = (int *)malloc(sizeof(int)*s))) // выделение памяти под строку матрицы
		{                                               // с проверкой выделена ли память
			printf("\nНедостаточно свободной памяти \nУуменьшите число ст-цов матрицы");
			for (j = 0; j < i; j++) free(*(p + j)); free(p); // освобождение памяти при ошибке
			p = nullptr;   // сброс указателя для повтора операции выделения памяти
			break;         // выход из цикла по i (выбора указателя на строку матрицы)
		}
	} while (!p);

	Vvod(p, n, s);
	system("CLS");
	printf("\nВведенная матрица");
	Print(p, n, s);
	Transp(p, n);
	printf("\n\nПреобразованная матрица");
	Print(p, n, s);
	Transp(p, n);
	printf("\n\nПреобразованная матрица");
	Print(p, n, s);
	for (i = 0; i<n; i++)  free(*(p + i));// освобождение памяти на которую указывает p[i]  
	free(p);                              // освобождение памяти на которую указывает p               
	return 0;
}

void Transp(int **MS, int n)
{
	static short int i=1, j;
	if (!MS)                           // проверка не нулевой ли указатель
	{
		puts("память для массива (матрицы) не выделена");
		return;
	}
	if (j >= i)                        // очередная строка матрицы обработана
	{                                  // ДО ДИАГОНАЛИ
		i++;                           // переходим в новой строке
		j = 0;                         // становимся в начало этой (новой) строки
	}
	if (i >= n)                        // транспонирование матрицы выполнено (выбраны все строки)
	{
		i = 1; j = 0;                  // для повторного вызова функции для другой матрицы
		return;
	}
	swap(MS, i, j, j, i);
	j++;
	Transp(MS, n);
}

