#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <stdexcept>
#include <iomanip>
#include <limits>
#include <algorithm>
#include <windows.h>

// Функция для проверки ввода
template<typename T>
T getInput(const std::string& prompt) {
    T value;
    while (true) {
        std::cout << prompt;
        if (std::cin >> value) {
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            return value;
        }
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        std::cout << "Invalid input. Please try again.\n";
    }
}

// Базовый класс
class ConfectioneryItem {
protected:
    std::string name;
    double price;
    std::vector<std::string> ingredients;
    int calories;

public:
    ConfectioneryItem(const std::string& name, double price, int calories)
            : name(name), price(price), calories(calories) {}

    virtual ~ConfectioneryItem() = default;

    virtual void displayInfo() const = 0;

    std::string getName() const { return name; }
    double getPrice() const { return price; }
    int getCalories() const { return calories; }

    void addIngredient(const std::string& ingredient) {
        ingredients.push_back(ingredient);
    }

    const std::vector<std::string>& getIngredients() const {
        return ingredients;
    }

    virtual void setName(const std::string& newName) { name = newName; }
    virtual void setPrice(double newPrice) { price = newPrice; }
    virtual void setCalories(int newCalories) { calories = newCalories; }
    virtual void setIngredients(const std::vector<std::string>& newIngredients) { ingredients = newIngredients; }
};

// Производный класс первого уровня - Выпечка
class BakedGood : public ConfectioneryItem {
protected:
    double weight;

public:
    BakedGood(const std::string& name, double price, double weight, int calories)
            : ConfectioneryItem(name, price, calories), weight(weight) {}

    double getWeight() const { return weight; }
    void setWeight(double newWeight) { weight = newWeight; }
};

// Производный класс второго уровня - Торт
class Cake : public BakedGood {
public:
    Cake(const std::string& name, double price, double weight, int calories)
            : BakedGood(name, price, weight, calories) {}

    void displayInfo() const override {
        std::cout << "Cake: " << name << "\nPrice: " << price << " USD\nWeight: " << weight << " kg\n";
    }

};

// Производный класс третьего уровня - Свадебный торт
class WeddingCake : public Cake {
private:
    int tiers;

public:
    WeddingCake(const std::string& name, double price, double weight, int tiers, int calories)
            : Cake(name, price, weight, calories), tiers(tiers) {}

    int getTiers() const { return tiers; }
    void setTiers(int newTiers) { tiers = newTiers; }

    void displayInfo() const override {
        std::cout << "Wedding Cake: " << name << "\nPrice: " << price << " USD\nWeight: " << weight << " kg\nTiers: " << tiers << "\n";
    }
};

// Производный класс - Печенье
class Cookie : public ConfectioneryItem {
private:
    std::string shape;

public:
    Cookie(const std::string& name, double price, const std::string& shape, int calories)
            : ConfectioneryItem(name, price, calories), shape(shape) {}

    std::string getShape() const { return shape; }
    void setShape(const std::string& newShape) { shape = newShape; }

    void displayInfo() const override {
        std::cout << "Cookie: " << name << "\nPrice: " << price << " USD\nShape: " << shape << "\n";
    }
};

// Класс для управления ассортиментом
class ConfectioneryManager {
private:
    std::vector<ConfectioneryItem*> items;

public:
    ~ConfectioneryManager() {
        for (auto item : items) {
            delete item;
        }
    }

    void addItem(ConfectioneryItem* item) {
        items.push_back(item);
    }

    void removeItem(const std::string& name) {
        auto it = std::find_if(items.begin(), items.end(),
                               [&name](const ConfectioneryItem* item) { return item->getName() == name; });
        if (it != items.end()) {
            delete *it;
            items.erase(it);
        }
    }

    void displayAllItems() const {
        std::cout << "\n" << std::string(120, '=') << "\n";
        std::cout << std::left
                  << std::setw(30) << "Name"
                  << std::setw(15) << "Price (USD)"
                  << std::setw(15) << "Weight (kg)"
                  << std::setw(15) << "Type"
                  << std::setw(15) << "Calories"
                  << std::setw(15) << "Additional"
                  << "Ingredients\n";
        std::cout << std::string(120, '-') << "\n";
        for (const auto item : items) {
            std::cout << std::left
                      << std::setw(30) << item->getName()
                      << std::setw(15) << std::fixed << std::setprecision(2) << item->getPrice()
                      << std::setw(15);

            if (auto cake = dynamic_cast<Cake*>(item)) {
                std::cout << std::fixed << std::setprecision(3) << cake->getWeight();
            } else {
                std::cout << "-";
            }

            std::cout << std::setw(15);

            std::string itemType;
            std::string additional;

            if (auto weddingCake = dynamic_cast<WeddingCake*>(item)) {
                itemType = "Wedding Cake";
                additional = std::to_string(weddingCake->getTiers()) + " tiers";
            } else if (dynamic_cast<Cake*>(item)) {
                itemType = "Cake";
            } else if (auto cookie = dynamic_cast<Cookie*>(item)) {
                itemType = "Cookie";
                additional = cookie->getShape();
            }

            std::cout << itemType << std::setw(15) << item->getCalories() << std::setw(15) << additional;

            // Выводим игнридиенты без разделителей
            const auto& ingredients = item->getIngredients();
            if (!ingredients.empty()) {
                std::cout << ingredients[0];
                for (size_t i = 1; i < ingredients.size(); ++i) {
                    std::cout << ", " << ingredients[i];
                }
            }
            std::cout << "\n";
        }
        std::cout << std::string(120, '=') << "\n";
    }

    ConfectioneryItem* findItem(const std::string& name) {
        auto it = std::find_if(items.begin(), items.end(),
                               [&name](const ConfectioneryItem* item) { return item->getName() == name; });
        return (it != items.end()) ? *it : nullptr;
    }

    void saveToFile(const std::string& filename) const {
        std::ofstream file(filename);
        if (!file) {
            throw std::runtime_error("Failed to open file for writing");
        }

        for (const auto item : items) {
            file << item->getName() << "|" << item->getPrice() << "|" << item->getCalories();

            if (auto cake = dynamic_cast<Cake*>(item)) {
                file << "|Cake|" << cake->getWeight();
                if (auto weddingCake = dynamic_cast<WeddingCake*>(cake)) {
                    file << "|" << weddingCake->getTiers();
                } else {
                    file << "|0";
                }
            } else if (auto cookie = dynamic_cast<Cookie*>(item)) {
                file << "|Cookie|" << cookie->getShape();
            }

            // Сохраняем ингредиенты
            file << "|";
            const auto& ingredients = item->getIngredients();
            for (size_t i = 0; i < ingredients.size(); ++i) {
                file << ingredients[i];
                if (i < ingredients.size() - 1) file << ";";
            }
            file << "\n";
        }

        file.close();
    }

    void loadFromFile(const std::string& filename) {
        std::ifstream file(filename);
        if (!file) {
            std::cout << "File " << filename << " not found. Creating a new file.\n";
            return;
        }

        // Очищаем текущий список изделий
        for (auto item : items) {
            delete item;
        }
        items.clear();

        std::string line;
        while (std::getline(file, line)) {
            std::istringstream iss(line);
            std::string name, type, shape, ingredientsStr;
            double price, weight;
            int calories, tiers;

            std::getline(iss, name, '|');
            iss >> price;
            iss.ignore();
            iss >> calories;
            iss.ignore();
            std::getline(iss, type, '|');

            ConfectioneryItem* item = nullptr;

            if (type == "Cake") {
                iss >> weight;
                iss.ignore();
                iss >> tiers;
                if (tiers > 0) {
                    item = new WeddingCake(name, price, weight, tiers, calories);
                } else {
                    item = new Cake(name, price, weight, calories);
                }
            } else if (type == "Cookie") {
                std::getline(iss, shape, '|');
                item = new Cookie(name, price, shape, calories);
            }

            if (item) {
                std::getline(iss, ingredientsStr);
                std::istringstream ingredientStream(ingredientsStr);
                std::string ingredient;
                while (std::getline(ingredientStream, ingredient, ';')) {
                    item->addIngredient(ingredient);
                }
                addItem(item);
            }
        }

        file.close();
        std::cout << "Data successfully loaded from file " << filename << "\n";
    }
};

// Класс для управления заказами
class Order {
private:
    std::vector<std::pair<ConfectioneryItem*, int>> items;

public:
    void addItem(ConfectioneryItem* item, int quantity) {
        items.emplace_back(item, quantity);
    }

    double calculateTotal() const {
        double total = 0;
        for (const auto& pair : items) {
            total += pair.first->getPrice() * pair.second;
        }
        return total;
    }

    void displayOrder() const {
        std::cout << "Your order:\n";
        std::cout << std::setw(20) << "Name" << std::setw(10) << "Qty" << std::setw(10) << "Price" << std::setw(10) << "Total\n";
        std::cout << std::string(50, '-') << "\n";
        for (const auto& pair : items) {
            std::cout << std::setw(20) << pair.first->getName()
                      << std::setw(10) << pair.second
                      << std::setw(10) << pair.first->getPrice()
                      << std::setw(10) << pair.first->getPrice() * pair.second << "\n";
        }
        std::cout << std::string(50, '-') << "\n";
        std::cout << "Total: " << calculateTotal() << " USD\n";
    }

    void saveToFile(const std::string& filename) const {
        std::string fullFilename = filename + ".txt";
        std::ofstream file(fullFilename);
        if (!file) {
            throw std::runtime_error("Failed to open file for writing: " + fullFilename);
        }

        file << "Order:\n";
        file << std::string(120, '-') << "\n";
        file << std::left
             << std::setw(30) << "Name"
             << std::setw(15) << "Quantity"
             << std::setw(15) << "Price"
             << std::setw(15) << "Total"
             << std::setw(15) << "Calories"
             << "Ingredients\n";
        file << std::string(120, '-') << "\n";

        int totalCalories = 0;
        for (const auto& pair : items) {
            ConfectioneryItem* item = pair.first;
            int quantity = pair.second;
            double itemPrice = item->getPrice();
            double itemTotal = itemPrice * quantity;
            int itemCalories = item->getCalories() * quantity;
            totalCalories += itemCalories;

            file << std::left
                 << std::setw(34) << item->getName()
                 << std::setw(34) << quantity
                 << std::setw(15) << std::fixed << std::setprecision(2) << itemPrice
                 << std::setw(15) << std::fixed << std::setprecision(2) << itemTotal
                 << std::setw(20) << itemCalories;

            const auto& ingredients = item->getIngredients();
            if (!ingredients.empty()) {
                file << ingredients[0];
                for (size_t i = 1; i < ingredients.size(); ++i) {
                    file << ", " << ingredients[i];
                }
            }
            file << "\n";
        }

        file << std::string(120, '-') << "\n";
        file << std::left
             << std::setw(75) << "Total:"
             << std::setw(15) << std::fixed << std::setprecision(2) << calculateTotal() << " USD\n";
        file << std::left
             << std::setw(75) << "Total Calories:"
             << totalCalories << "\n";

        file.close();
        std::cout << "Order successfully saved to file: " << fullFilename << "\n";
    }
};

int main() {
    // Устанавливаем кодировку консоли в UTF-8
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    char buffer[MAX_PATH];
    GetCurrentDirectory(MAX_PATH, buffer);
    std::cout << "Current working directory: " << buffer << std::endl;

    ConfectioneryManager manager;
    Order currentOrder;

    try {
        manager.loadFromFile("confectionery.txt");
    } catch (const std::exception& e) {
        std::cout << "Error loading data: " << e.what() << "\n";
    }

    std::cout << "Current list of items:\n";
    manager.displayAllItems();

    while (true) {
        std::cout << "\n" << std::string(50, '=') << "\n";
        std::cout << "Menu:\n" << std::string(50, '-') << "\n"
                  << "1. Show all items\n"
                  << "2. Add item\n"
                  << "3. Remove item\n"
                  << "4. Show item information\n"
                  << "5. Edit item\n"  // New menu item
                  << "6. Add to order\n"
                  << "7. Show current order\n"
                  << "8. Save order\n"
                  << "9. Exit\n"
                  << std::string(50, '-') << "\n"
                  << "Choose an action: ";

        int choice = getInput<int>("");

        std::cout << std::string(50, '=') << "\n";

        switch (choice) {
            case 1:
                manager.displayAllItems();
                break;
            case 2: {
                std::string name = getInput<std::string>("Enter name: ");
                double price = getInput<double>("Enter price: ");
                int calories = getInput<int>("Enter calories per 100g: ");

                std::cout << "Enter ingredients (separated by commas): ";
                std::string ingredientsInput;
                std::getline(std::cin, ingredientsInput);
                std::vector<std::string> ingredients;
                std::istringstream iss(ingredientsInput);
                std::string ingredient;
                while (std::getline(iss, ingredient, ',')) {
                    ingredients.push_back(ingredient);
                }

                std::cout << "Choose item type:\n"
                          << "1. Cake\n"
                          << "2. Wedding Cake\n"
                          << "3. Cookie\n";
                int typeChoice = getInput<int>("Enter type number: ");

                ConfectioneryItem* newItem = nullptr;

                switch (typeChoice) {
                    case 1: {
                        double weight = getInput<double>("Enter cake weight (kg): ");
                        newItem = new Cake(name, price, weight, calories);
                        break;
                    }
                    case 2: {
                        double weight = getInput<double>("Enter wedding cake weight (kg): ");
                        int tiers = getInput<int>("Enter number of tiers: ");
                        newItem = new WeddingCake(name, price, weight, tiers, calories);
                        break;
                    }
                    case 3: {
                        std::string shape = getInput<std::string>("Enter cookie shape: ");
                        newItem = new Cookie(name, price, shape, calories);
                        break;
                    }
                    default:
                        std::cout << "Invalid item type choice.\n";
                        break;
                }

                if (newItem) {
                    for (const auto& ing : ingredients) {
                        newItem->addIngredient(ing);
                    }
                    manager.addItem(newItem);
                    std::cout << "Item successfully added.\n";
                    manager.saveToFile("confectionery.txt");
                    std::cout << "Current list of items:\n";
                    manager.displayAllItems();
                }
                break;
            }
            case 3: {
                std::string name = getInput<std::string>("Enter the name of the item to remove: ");
                manager.removeItem(name);
                break;
            }
            case 4: {
                std::string name = getInput<std::string>("Enter the name of the item: ");
                ConfectioneryItem *item = manager.findItem(name);
                if (item) {
                    item->displayInfo();
                    std::cout << "Ingredients: ";
                    for (const auto &ingredient: item->getIngredients()) {
                        std::cout << ingredient << ", ";
                    }
                    std::cout << "\n";
                } else {
                    std::cout << "Item not found\n";
                }
                break;
            }
            case 5: {
                std::string name = getInput<std::string>("Enter the name of the item to edit: ");
                ConfectioneryItem *item = manager.findItem(name);
                if (item) {
                    std::cout << "Current item details:\n";
                    item->displayInfo();

                    std::string newName = getInput<std::string>("Enter new name (or 0 to keep current): ");
                    if (newName != "0") item->setName(newName);

                    double newPrice = getInput<double>("Enter new price (or 0 to keep current): ");
                    if (newPrice != 0) item->setPrice(newPrice);

                    int newCalories = getInput<int>("Enter new calories per 100g (or 0 to keep current): ");
                    if (newCalories != 0) item->setCalories(newCalories);

                    std::cout << "Current ingredients: ";
                    for (const auto& ing : item->getIngredients()) {
                        std::cout << ing << ", ";
                    }
                    std::cout << "\nEnter new ingredients (separated by commas, or '0' to keep current): ";
                    std::string newIngredientsInput;
                    std::getline(std::cin, newIngredientsInput);
                    if (newIngredientsInput != "0") {
                        std::vector<std::string> newIngredients;
                        std::istringstream iss(newIngredientsInput);
                        std::string ingredient;
                        while (std::getline(iss, ingredient, ',')) {
                            newIngredients.push_back(ingredient);
                        }
                        item->setIngredients(newIngredients);  // Предполагается, что у вас есть метод setIngredients
                    }

                    if (auto cake = dynamic_cast<Cake *>(item)) {
                        double newWeight = getInput<double>("Enter new weight (or 0 to keep current): ");
                        if (newWeight != 0) cake->setWeight(newWeight);

                        if (auto weddingCake = dynamic_cast<WeddingCake *>(cake)) {
                            int newTiers = getInput<int>("Enter new number of tiers (or 0 to keep current): ");
                            if (newTiers != 0) weddingCake->setTiers(newTiers);
                        }
                    } else if (auto cookie = dynamic_cast<Cookie *>(item)) {
                        std::string newShape = getInput<std::string>("Enter new shape (or '0' to keep current): ");
                        if (newShape != "0") cookie->setShape(newShape);
                    }

                    std::cout << "Item successfully edited.\n";
                    manager.saveToFile("confectionery.txt");
                } else {
                    std::cout << "Item not found\n";
                }
                break;
            }
            case 6: {
                std::string name = getInput<std::string>("Enter the name of the item to add to the order: ");
                ConfectioneryItem *item = manager.findItem(name);
                if (item) {
                    int quantity = getInput<int>("Enter quantity: ");
                    currentOrder.addItem(item, quantity);
                } else {
                    std::cout << "Item not found\n";
                }
                break;
            }
            case 7:
                currentOrder.displayOrder();
                break;
            case 8: {
                std::string filename = getInput<std::string>("Enter the filename to save the order: ");
                try {
                    currentOrder.saveToFile(filename);
                    std::cout << "Order saved to file " << filename << "\n";
                } catch (const std::exception &e) {
                    std::cout << "Error saving order: " << e.what() << "\n";
                }
                break;
            }
            case 9:
                try {
                    manager.saveToFile("confectionery.txt");
                    std::cout << "Data saved.\n";
                } catch (const std::exception &e) {
                    std::cout << "Error saving data: " << e.what() << "\n";
                }
                std::cout << "Goodbye!\n";
                return 0;
            default:
                std::cout << "Invalid choice. Please try again.\n";
                break;
        }
    }
    return 0;
}