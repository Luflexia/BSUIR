#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <stdexcept>
#include <iomanip>
#include <limits>
#include <algorithm>
#include <windows.h>
#include <codecvt>

// Базовый класс
class ConfectioneryItem {
protected:
    std::string name;
    double price;
    std::vector<std::string> ingredients;

public:
    ConfectioneryItem(const std::string& name, double price) : name(name), price(price) {}

    virtual ~ConfectioneryItem() = default;

    virtual void displayInfo() const = 0;
    virtual double calculateNutritionalValue() const = 0;

    std::string getName() const { return name; }
    double getPrice() const { return price; }

    void addIngredient(const std::string& ingredient) {
        ingredients.push_back(ingredient);
    }

    const std::vector<std::string>& getIngredients() const {
        return ingredients;
    }
};

// Производный класс первого уровня - Выпечка
class BakedGood : public ConfectioneryItem {
protected:
    double weight;

public:
    BakedGood(const std::string& name, double price, double weight)
            : ConfectioneryItem(name, price), weight(weight) {}

    double getWeight() const { return weight; }
};

// Производный класс второго уровня - Торт
class Cake : public BakedGood {
public:
    Cake(const std::string& name, double price, double weight)
            : BakedGood(name, price, weight) {}

    void displayInfo() const override {
        std::cout << "Cake: " << name << "\nPrice: " << price << " USD\nWeight: " << weight << " kg\n";
    }

    double calculateNutritionalValue() const override {
        return weight * 300; // предположим, что 1 кг торта = 300 ккал
    }
};

// Производный класс третьего уровня - Свадебный торт
class WeddingCake : public Cake {
private:
    int tiers;

public:
    WeddingCake(const std::string& name, double price, double weight, int tiers)
            : Cake(name, price, weight), tiers(tiers) {}

    void displayInfo() const override {
        std::cout << "Wedding Cake: " << name << "\nPrice: " << price << " USD\nWeight: " << weight << " kg\nTiers: " << tiers << "\n";
    }

    double calculateNutritionalValue() const override {
        return Cake::calculateNutritionalValue() * 1.2;
    }

    int getTiers() const { return tiers; } // Добавляем этот метод
};

// Производный класс - Печенье
class Cookie : public ConfectioneryItem {
private:
    int quantity;

public:
    Cookie(const std::string& name, double price, int quantity)
            : ConfectioneryItem(name, price), quantity(quantity) {}

    void displayInfo() const override {
        std::cout << "Cookie: " << name << "\nPrice: " << price << " USD\nQuantity: " << quantity << " pcs.\n";
    }

    double calculateNutritionalValue() const override {
        return quantity * 50;
    }

    int getQuantity() const { return quantity; } // Добавляем этот метод
};

// Класс для управления ассортиментом
class ConfectioneryManager {
private:
    std::vector<ConfectioneryItem*> items;

public:
    ~ConfectioneryManager() {
        for (auto item : items) {
            delete item;
        }
    }

    void addItem(ConfectioneryItem* item) {
        items.push_back(item);
    }

    void removeItem(const std::string& name) {
        auto it = std::find_if(items.begin(), items.end(),
                               [&name](const ConfectioneryItem* item) { return item->getName() == name; });
        if (it != items.end()) {
            delete *it;
            items.erase(it);
        }
    }

    void displayAllItems() const {
        std::cout << "\n" << std::string(90, '=') << "\n";
        std::cout << std::left
                  << std::setw(30) << "Name"
                  << std::setw(15) << "Price (USD)"
                  << std::setw(15) << "Weight (kg)"
                  << std::setw(15) << "Type"
                  << std::setw(15) << "Additional" << "\n";
        std::cout << std::string(90, '-') << "\n";
        for (const auto item : items) {
            std::cout << std::left
                      << std::setw(30) << item->getName()
                      << std::setw(15) << std::fixed << std::setprecision(2) << item->getPrice()
                      << std::setw(15);

            if (auto cake = dynamic_cast<Cake*>(item)) {
                std::cout << std::fixed << std::setprecision(2) << cake->getWeight();
            } else {
                std::cout << "-";
            }

            std::cout << std::setw(15);

            std::string itemType;
            std::string additional;

            if (auto weddingCake = dynamic_cast<WeddingCake*>(item)) {
                itemType = "Wedding Cake";
                additional = std::to_string(weddingCake->getTiers()) + " tiers";
            } else if (dynamic_cast<Cake*>(item)) {
                itemType = "Cake";
            } else if (auto cookie = dynamic_cast<Cookie*>(item)) {
                itemType = "Cookie";
                additional = std::to_string(cookie->getQuantity()) + " pcs";
            }

            std::cout << itemType << std::setw(15) << additional;
            std::cout << "\n";
        }
        std::cout << std::string(90, '=') << "\n";
    }

    ConfectioneryItem* findItem(const std::string& name) {
        auto it = std::find_if(items.begin(), items.end(),
                               [&name](const ConfectioneryItem* item) { return item->getName() == name; });
        return (it != items.end()) ? *it : nullptr;
    }

    void saveToFile(const std::string& filename) const {
        std::ofstream file(filename, std::ios::out | std::ios::binary);
        if (!file) {
            throw std::runtime_error("Failed to open file for writing");
        }

        // Записываем BOM (Byte Order Mark) для UTF-8
        unsigned char bom[] = { 0xEF, 0xBB, 0xBF };
        file.write(reinterpret_cast<char*>(bom), sizeof(bom));

        for (const auto item : items) {
            std::string itemType;
            if (dynamic_cast<WeddingCake*>(item)) {
                itemType = "WeddingCake";
            } else if (dynamic_cast<Cake*>(item)) {
                itemType = "Cake";
            } else if (dynamic_cast<Cookie*>(item)) {
                itemType = "Cookie";
            }

            file << itemType << "," << item->getName() << "," << item->getPrice();

            if (auto cake = dynamic_cast<Cake*>(item)) {
                file << "," << cake->getWeight();
            } else if (auto cookie = dynamic_cast<Cookie*>(item)) {
                file << "," << cookie->calculateNutritionalValue() / 50;
            }
            file << "\n";
        }

        file.close();
    }

    void loadFromFile(const std::string& filename) {
        std::ifstream file(filename, std::ios::in | std::ios::binary);
        if (!file) {
            std::cout << "File " << filename << " not found. Creating a new file.\n";
            std::ofstream newFile(filename, std::ios::out | std::ios::binary);
            if (!newFile) {
                throw std::runtime_error("Failed to create file " + filename);
            }
            newFile.close();
            return; // Выходим из метода, так как файл пустой
        }

        // Очищаем текущий список изделий
        for (auto item : items) {
            delete item;
        }
        items.clear();

        // Пропускаем BOM, если он есть
        char bom[3];
        file.read(bom, 3);
        if (!(bom[0] == (char)0xEF && bom[1] == (char)0xBB && bom[2] == (char)0xBF)) {
            file.seekg(0); // Если BOM нет, возвращаемся в начало файла
        }

        std::string line;
        while (std::getline(file, line)) {
            std::istringstream iss(line);
            std::string type, name;
            double price, weight;
            int quantity, tiers;

            if (std::getline(iss, type, ',') &&
                std::getline(iss, name, ',') &&
                iss >> price &&
                iss.ignore()) {

                if (type == "Cake" && iss >> weight) {
                    addItem(new Cake(name, price, weight));
                } else if (type == "Cookie" && iss >> quantity) {
                    addItem(new Cookie(name, price, quantity));
                } else if (type == "Wedding Cake" && iss >> weight && iss.ignore() && iss >> tiers) {
                    addItem(new WeddingCake(name, price, weight, tiers));
                }
            }
        }

        file.close();
        std::cout << "Data successfully loaded from file " << filename << "\n";
    }
};

// Класс для управления заказами
class Order {
private:
    std::vector<std::pair<ConfectioneryItem*, int>> items;

public:
    void addItem(ConfectioneryItem* item, int quantity) {
        items.emplace_back(item, quantity);
    }

    double calculateTotal() const {
        double total = 0;
        for (const auto& pair : items) {
            total += pair.first->getPrice() * pair.second;
        }
        return total;
    }

    void displayOrder() const {
        std::cout << "Your order:\n";
        std::cout << std::setw(20) << "Name" << std::setw(10) << "Qty" << std::setw(10) << "Price" << std::setw(10) << "Total\n";
        std::cout << std::string(50, '-') << "\n";
        for (const auto& pair : items) {
            std::cout << std::setw(20) << pair.first->getName()
                      << std::setw(10) << pair.second
                      << std::setw(10) << pair.first->getPrice()
                      << std::setw(10) << pair.first->getPrice() * pair.second << "\n";
        }
        std::cout << std::string(50, '-') << "\n";
        std::cout << "Total: " << calculateTotal() << " USD\n";
    }

    void saveToFile(const std::string& filename) const {
        std::string fullFilename = filename + ".txt";
        std::ofstream file(fullFilename);
        if (!file) {
            throw std::runtime_error("Failed to open file for writing: " + fullFilename);
        }

        file << "Order:\n";
        file << std::string(80, '-') << "\n";
        file << std::left << std::setw(30) << "Item Name"
             << std::right << std::setw(10) << "Quantity"
             << std::setw(20) << "Price"
             << std::setw(20) << "Total\n";
        file << std::string(80, '-') << "\n";

        for (const auto& pair : items) {
            ConfectioneryItem* item = pair.first;
            int quantity = pair.second;
            double itemPrice = item->getPrice();
            double itemTotal = itemPrice * quantity;

            file << std::left << std::setw(30) << item->getName()
                 << std::right << std::setw(10) << quantity
                 << std::setw(32) << std::fixed << std::setprecision(2) << itemPrice
                 << std::setw(22) << std::fixed << std::setprecision(2) << itemTotal << "\n";
        }

        file << std::string(80, '-') << "\n";
        file << std::left << std::setw(60) << "Total:"
             << std::right << std::setw(20) << std::fixed << std::setprecision(2) << calculateTotal() << " USD\n";

        file.close();
        std::cout << "Order successfully saved to file: " << fullFilename << "\n";
    }
};

// Функция для проверки ввода
template<typename T>
T getInput(const std::string& prompt) {
    T value;
    while (true) {
        std::cout << prompt;
        if (std::cin >> value) {
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            return value;
        }
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        std::cout << "Invalid input. Please try again.\n";
    }
}

int main() {
    // Устанавливаем кодировку консоли в UTF-8
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    char buffer[MAX_PATH];
    GetCurrentDirectory(MAX_PATH, buffer);
    std::cout << "Current working directory: " << buffer << std::endl;

    ConfectioneryManager manager;
    Order currentOrder;

    try {
        manager.loadFromFile("confectionery.txt");
    } catch (const std::exception& e) {
        std::cout << "Error loading data: " << e.what() << "\n";
    }

    std::cout << "Current list of items:\n";
    manager.displayAllItems();

    try {
        manager.loadFromFile("confectionery.txt");
    } catch (const std::exception& e) {
        std::cout << "Error loading data: " << e.what() << "\n";
    }

    while (true) {
        std::cout << "\n" << std::string(50, '=') << "\n";
        std::cout << "Menu:\n" << std::string(50, '-') << "\n"
                  << "1. Show all items\n"
                  << "2. Add item\n"
                  << "3. Remove item\n"
                  << "4. Show item information\n"
                  << "5. Add to order\n"
                  << "6. Show current order\n"
                  << "7. Save order\n"
                  << "8. Exit\n"
                  << std::string(50, '-') << "\n"
                  << "Choose an action: ";

        int choice = getInput<int>("");

        std::cout << std::string(50, '=') << "\n";

        switch (choice) {
            case 1:
                manager.displayAllItems();
                break;
            case 2: {
                std::string name = getInput<std::string>("Enter name: ");
                double price = getInput<double>("Enter price: ");

                std::cout << "Choose item type:\n"
                          << "1. Cake\n"
                          << "2. Wedding Cake\n"
                          << "3. Cookie\n";
                int typeChoice = getInput<int>("Enter type number: ");

                switch (typeChoice) {
                    case 1: {
                        double weight = getInput<double>("Enter cake weight (kg): ");
                        manager.addItem(new Cake(name, price, weight));
                        break;
                    }
                    case 2: {
                        double weight = getInput<double>("Enter wedding cake weight (kg): ");
                        int tiers = getInput<int>("Enter number of tiers: ");
                        manager.addItem(new WeddingCake(name, price, weight, tiers));
                        break;
                    }
                    case 3: {
                        int quantity = getInput<int>("Enter quantity of cookies: ");
                        manager.addItem(new Cookie(name, price, quantity));
                        break;
                    }
                    default:
                        std::cout << "Invalid item type choice.\n";
                        break;
                }

                if (typeChoice >= 1 && typeChoice <= 3) {
                    std::cout << "Item successfully added.\n";
                    manager.saveToFile("confectionery.txt");  // Сохраняем изменения
                    std::cout << "Current list of items:\n";
                    manager.displayAllItems();  // Показываем обновленный список
                }
                break;
            }
            case 3: {
                std::string name = getInput<std::string>("Enter the name of the item to remove: ");
                manager.removeItem(name);
                break;
            }
            case 4: {
                std::string name = getInput<std::string>("Enter the name of the item: ");
                ConfectioneryItem* item = manager.findItem(name);
                if (item) {
                    item->displayInfo();
                    std::cout << "Nutritional value: " << item->calculateNutritionalValue() << " kcal\n";
                    std::cout << "Ingredients: ";
                    for (const auto& ingredient : item->getIngredients()) {
                        std::cout << ingredient << ", ";
                    }
                    std::cout << "\n";
                } else {
                    std::cout << "Item not found\n";
                }
                break;
            }
            case 5: {
                std::string name = getInput<std::string>("Enter the name of the item to add to the order: ");
                ConfectioneryItem* item = manager.findItem(name);
                if (item) {
                    int quantity = getInput<int>("Enter quantity: ");
                    currentOrder.addItem(item, quantity);
                } else {
                    std::cout << "Item not found\n";
                }
                break;
            }
            case 6:
                currentOrder.displayOrder();
                break;
            case 7: {
                std::string filename = getInput<std::string>("Enter the filename to save the order: ");
                try {
                    currentOrder.saveToFile(filename);
                    std::cout << "Order saved to file " << filename << "\n";
                } catch (const std::exception& e) {
                    std::cout << "Error saving order: " << e.what() << "\n";
                }
                break;
            }
            case 8:
                try {
                    manager.saveToFile("confectionery.txt");
                    std::cout << "Data saved.\n";
                } catch (const std::exception& e) {
                    std::cout << "Error saving data: " << e.what() << "\n";
                }
                std::cout << "Goodbye!\n";
                return 0;
            default:
                std::cout << "Invalid choice. Please try again.\n";
                break;
        }
    }

    return 0;
}